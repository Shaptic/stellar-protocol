## Preamble

```
SEP: 0039
Title: On-Chain NFTs: Storage of Non-Fungible Assets
Authors: George Kudrayvtsev (@Shaptic), Tyler van der Hoeven (@tyvdh)
Track: Standard
Status: Draft
Created: 2021-11-22
Updated: 2021-12-01
Version: 0.1.0
Discussion: https://github.com/stellar/stellar-protocol/pull/1090/
```


## Simple Summary
This SEP describes a specific way to store arbitrary binary data on-chain with the goal of standardizing the way NFTs are represented in the Stellar ledger.


## Dependencies
While not an explicit dependency, there may be a future CAP that modifies the protocol to allow a 128-byte row of ManageData to be arbitrarily divided into the string "key" and binary "data" portions, as opposed to the current model of having strict 64-byte halves.

With that CAP, the data model introduced [below](#specification) could/should change to be friendlier and more optimized.


## Motivation
With NFT marketplaces on the rise in the Stellar network (e.g. [Litemint](https://litemint.com/) and [Stellar Quest](https://quest.stellar.org/)), it's important to establish standards to ensure cross-compatibility of NFTs. Certain platforms may choose to store their asset---whether that be an image as we often see today or any arbitrary digital trinket---on the Stellar ledger itself rather than delegating to an off-chain storage mechanism such as [IPFS](https://ipfs.io/).

A standard storage mechanism will help these marketplaces and wallets render or otherwise represent the NFT within their applications, enhancing their transferability.


## Abstract
We present an efficient encoding mechanism to store arbitrary binary data on the Stellar ledger via the `ManageData` operation, specifically catering towards NFTs. It will concatenate a special SEP-39 header alongside a [Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml) containing asset metadata alongside the aforementioned encoded-text as keys and raw binary data as values.


## Specification
First, we will discuss a common NFT issuance model and its ownership implications. This is not a required model, but sets the stage for why a standardized encoding of digital assets is necessary.

**Warning**: Because of how indexing works (that is, each data entry for the asset begins with an index), an account can only hold a single SEP-39 asset at a time. Users should also take care not to have colliding keys that may interfere with ordering, and should lean on the (optional) checksum parameter if they're worried about decoding inconsistencies.

### NFT Issuance
Given an arbitrary digital asset, here's how issuance typically works:

  1. An account is created to represent the digital asset on the ledger
  2. The account stores the entire digital asset within its managed data entries.
  3. The account issues a Stellar asset representing ownership over the digital asset we just stored.
  4. Any account holding that Stellar asset lays claim to the digital asset.

Notice that ownership of the token directly conveys ownership of a unit of the asset, entirely within the Stellar ledger. Other scenarios such as locking down the issuing account to avoid supply increases, ownership transfers via payments, etc. are built on top of this basic model and are thus extraneous to this SEP.

Note also that this SEP does not address concerns around *immutability*. While there is an optional checksum component (addressed later), the account itself is free to modify the data at-will if it is not locked.

Our exclusive focus in this SEP is Step 2: **storing the asset within the account.**

### Data Format
We begin by describing the raw data format, then dive into each component:

  - index (2 bytes)
  - version (1 byte)
  - metadata length, `n` (varying)
  - metadata (`n` bytes)
  - binary data (varying)

For example,

    00|1|26|text/plain;l=13,image/webp|TPwJh>}A"=r@@Y?Fetc...

(Here, the `|` characters are semantic, included just to separate the pieces in the list above; they are not actually in the data itself.)

The following sections break down each component in detail.

#### Index
Since an account can only have 1000 entries, we only need 10 bits for an index field. We _only_ need indices present so that the data entries are ASCII-sortable in Horizon. In fact, decoders can ignore it entirely if they wish. Thus, the index is expressed as a "base 36" value: 0-9 then a-z.

A valid SEP-39 entry always begins with `00`, indicating that this is the 0th row of data. In fact, every row's key _must_ begin with a two-character, [Base36] index.

---------

**Author's note**: This portion is definitely up for debate. Base36 (well, more accurately, a radix of 36) allows us to shave a byte off of each row (saving up to 1kB total), but we could stick to a 000-999 model (stringified integer) for simplicity. We could also do `aa` through `zz`, because as noted, the indices are _purely_ for sorting. 

Note that supporting a 36-radix is trivial in any language, since we know the value is strictly an integer. For example,

```python
import string 
ALPHABET = string.digits + string.ascii_lowercase

def int_to_b36(i: int) -> str:
    d, r = divmod(i, len(ALPHABET))
    return ALPHABET[d] + ALPHABET[r]

def b36_to_int(s: str) -> int:
    return ALPHABET.index(s[0]) * len(ALPHABET) + ALPHABET.index(s[1])
```

---------

#### Version
The first entry's index is followed by the version string. For the current version of this SEP, this is just `1`.

#### Metadata
The **metadata** is a comma-separated list of [Media Type]s alongside any associated parameters.

It is prefixed by a **length**, which is just a stringified integer (that is, a 32-byte metadata will have "32" as its length). When parsing, you should consume characters until hitting a non-digit, since a valid [Media Type] will never start with a digit. Note that row indices are not included in the metadata length.

There is only one standardized parameter:

  * `l`: this defines the *length* (in _raw_ bytes, not encoded data) of this media type within the binary data

You may include others as you see fit.

If there is more than one [Media Type], the length parameter `l` _must_ be set for all but the last type. If there is only one, it may be omitted entirely.

Media types are separated by a comma (`,`) character. For example, this metadata tells us that there text followed by an image within the binary buffer:

    text/plain;l=13,image/png

#### Binary Data
With the header out of the way, we need to describe the way the remaining binary data should be represented in `ManageData` entries.

Since the _key_ is restricted specifically to printable characters (ref: Stellar Core's [`isString32Valid()`](https://github.com/stellar/stellar-core/blob/b031954458df3bb31d8d98f136c6fee40523a10d/src/util/types.cpp#L89-L101) and C's [`isprint()`](https://en.cppreference.com/w/cpp/string/byte/isprint)), this gives us an encoding space of 95 characters or ~6.5 bits per character (a ~25% reduction in the space). From our research, the [BasE91] encoding scheme is closest to this theoretical limit.

The _value_ can be any binary data; thus, no encoding is necessary.

All of the binary data is thus prepended with an index, the next BasE91-encoded chunk sized to fit into the 64-length key string, and the next 64-byte binary chunk as the value.

If the final entry fits into the key (that is, the value is not necessary), the encoder _must_ set the value to an empty buffer (as opposed to `nil` or `null`). Otherwise, this will delete the entry.

If there are multiple media types (see [above](#metadata)), the binary data should be _encoded as one big stream_, rather than encoded separately. This eases decoding.

#### Implementation Note
Because you cannot predict the length of your encoded string without doing the encoding itself, it will be necessary to use trial-and-error to find the longest binary chunk that fits in <= 64 bytes. While this does mildly impact encoding time, it ensures optimality on-chain.

### Example
Here is an example asset stored in SEP-39 format:

| Key | Value |
|:----|:-----:|
| 00117text/plain;n=rick'ZP..<etc>.. | .. 64 bytes .. |
| 01^gp@Io1Tc%ZEYkE#^IR`0e%..<etc>.. | .. 64 bytes .. |
| 02yO){B&mA#_1:W8{lTCvnu8j..<etc>.. | .. 64 bytes .. |
| ... etc ... |
| a2ZBP>1]TX2$g%B' | <empty buffer> |

There are 322 (`a2`) rows and 17 characters of metadata: `text/plain;n=rick`.

### Pricing Implications
Every additional `ManageData` entry encurs an increase in the base reserve required by an account by 0.5 XLM. Some napkin-math pricing tables ensue:

| Data Size | ManageData Entries | Cost (XLM) |
|----------:|--------------------|------------|
|  10 B     | 1                  | 0.5        |
|   1 KB    | 9                  | 4.5        |
|  50 KB    | 418                | 209        |
| 112 KB    | 937                | 468.5      |
|   1 MB    | 8358               | 4179       |

Based on an approximation formula to account for encoding expanding the binary size by 10-15%:

    ceil(|data| / ((64 / 1.15) + 64))

Note that accounts are limited to 1000 sub-entries (so just over 100 KiB), so larger assets would need to either be split across multiple accounts or stored off-chain. This SEP does not address this.

### Example Implementation
The following section will include an example Python implementation of this SEP once it exists the _Draft_ phase.

```python
```


## Design Rationale
Due to the ever-evolving nature of the crypto space, we should not restrict ourselves to the specific use cases of NFTs we have today. Therefore, instead of catering directly towards a particular image format, we provide a specification for storing _arbitrary_ data.

However, we still designed the specification with NFTs in mind, stopping short of defining a universal spec for storing data on-chain. There are obviously many ways to encode arbitrary data in a text stream. However, due to the high cost of storing data on chain, every byte counts, so we aim to have an efficient design.

Keeping in mind the restrictions on `ManageData`---specifically, that the key *must* be made of printable ASCII characters, while the value *can* be any bytes---we need the most efficient encoder of binary to text data we can find. In a similar vein, we _could_ encode the binary values of each `ManageData` row to have consistency across keys and values, but this would be unnecessarily sacrificing a non-trivial efficiency.

While BasE91 is a little more esoteric than the near-universal base64, libraries exist in many languages and the efficient gain is significant enough to be worth the additional implementation overhead. The implementation itself is also very straightforward (for example, [here](https://github.com/aberaud/base91-python/blob/master/base91.py) is a one-page Python implementation).

A comparison with alternative encoders follows below. The tests were done by using the same specification as above on random data. Random data accurately reflects most _compressed_ data, and (lossless) compression should always be used to ensure no extra rows are needed on chain.

  * `base64`: +5% more entries, on average
  * `uuencode`: +20%
  * `hex`: +24%

If we also encode the value with BasE91 (for consistency across keys and values), we need +13% more entries.


## Security Concerns
The BasE91 encoding does not have the web (or JSON) in mind. Any rendering of the actual entries will need to take care to do proper escaping.

A malicious account could have data entries whose indices interleave with the SEP-39 entries. If this is a concern, care should be taken to (a) ensure that indices are correct (that is, increment each time) and (b) validate a checksum on the data.


[Base32]: https://en.wikipedia.org/wiki/Base36
[BasE91]: http://base91.sourceforge.net/
[Media Type]: https://www.iana.org/assignments/media-types/media-types.xhtml
